--1 문자열 결합
SELECT CONCAT('마당','서점')
FROM DUAL;
--1-1 대한, 민국, 만세 CONCAT()
SELECT CONCAT(CONCAT('대한','민국'), '만세')
FROM DUAL;
--2 문자열 결합
SELECT '마당'||'서점'
FROM DUAL;
--3 첫글자만 대문자로 나머지 소문자로
SELECT INITCAP('tHE soap')
FROM DUAL;
--4 소문자로 변경
SELECT LOWER('MR.SCOTT')
FROM DUAL;
--5 왼쪽에 남는 공간을 지정 문자로 채우기
SELECT LPAD('Page 1', 10, '*')
FROM DUAL;
--6 왼쪽에 나오는 지정된 문자들을 삭제
SELECT LTRIM('<======><><>==>BROWNING<==>','<>=')
FROM DUAL;
--7 오른쪽에 나오는 지정된 문자들을 삭제
SELECT RTRIM('<======><><>==>BROWNING<==>','<>=')
FROM DUAL;
--8 주어진 문자(열)를 다른 문자(열)로 대체
SELECT REPLACE('JACK and JUE', 'J','BL') 
FROM DUAL;
--9 오른쪽 남는 부분을 지정 문자로 채우기
SELECT RPAD('Page 1', 10, '*')
FROM DUAL;
--10 주어진 문자열의 특정 위치부터 몇개를 선택
SELECT SUBSTR('ABCDEFG',4,3)
FROM DUAL;
--11 왼쪽에서 몇번째 글자 이후 전체 선택
SELECT SUBSTR('ABCDEFG',2)
FROM DUAL;
--12 오른쪽 몇번째 글자 이후 전체 선택
SELECT SUBSTR('ABCDEFG',-2)
FROM DUAL;
--13 양쪽에 나오는 지정 문자 삭제
SELECT TRIM('=' FROM '==>BROWNING<==')
FROM DUAL;
--14 - 위치 찾기
SELECT INSTR('250101-3876546','-',1,1)
FROM DUAL;
--15 주민번호 중 - 이후의 숫자들만
SELECT SUBSTR('250101-3876546', INSTR('250101-3876546','-',1,1)+1)
FROM DUAL;
--16 생년월일 추출 후 20을 붙이기
SELECT CONCAT('20',SUBSTR('250101-3876546',1,6))
FROM DUAL;
--17 글자의 길이
SELECT LENGTH('ABCDE')
FROM DUAL;
--18  
SELECT BOOKID, REPLACE(BOOKNAME, '야구', '농구') BOOKNAME, PUBLISHER, PRICE
FROM BOOK;
--19 굿스포츠에서 출판한 도서 제목과 그 제목의 글자수 LENGTH, LENGTHB:바이트수, 영문자: 한글자: 1BYTE, 한글: 3BYTE
SELECT BOOKNAME "제목", LENGTH(BOOKNAME) "글자수", LENGTHB(BOOKNAME) "바이트수"
FROM BOOK
WHERE PUBLISHER = '굿스포츠';
--20 고객의 성과 이름 검색
SELECT SUBSTR(NAME,1,1) AS 성, SUBSTR(NAME, 2) AS 이름
FROM CUSTOMER;
--21 성별 고객수
SELECT SUBSTR(NAME, 1, 1) "성" ,COUNT(*) "인원수"
FROM CUSTOMER
GROUP BY SUBSTR(NAME, 1,1)
ORDER BY 1;
--22  TO_DATE() : 문장열을 날짜형으로 변환  오늘로부터 100일 뒤의 날짜
SELECT TO_DATE('2025-04-14','yyyy-mm-dd')+100
FROM DUAL;
--문자열에 +100 : 불가
SELECT '2025-04-14'+100
FROM DUAL;
--100일전의 날짜 가능
SELECT TO_DATE('2025-04-14','yyyy-mm-dd')+100
FROM DUAL;
--23 오늘의 날짜
SELECT SYSDATE
FROM DUAL;
--24 오늘의 날짜와 시간
SELECT TO_CHAR(SYSDATE, 'YYYY/MM/DD HH24:MI:SS A.M.')
FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'YYYY"년"MM"월"DD"일" HH24:MI:SS AM')
FROM DUAL;
--25 오늘 이후 한달 뒤의 날짜 ADD_MONTHS(날짜, 숫자) : 숫자만큼 지난 날짜
SELECT ADD_MONTHS(SYSDATE,1)
FROM DUAL;
--26 자기생일에서 3개월 뒤의 날짜
SELECT ADD_MONTHS('2025-01-01',3)
FROM DUAL;
--27 자기 생일이 있는 달의 마지막 날짜 : LAST_DAY() 
SELECT LAST_DAY('2025-04-01')
FROM DUAL;
--28 오늘의 요일 출력 -d: 요일에 해당하는 숫자, 일: 1, 월:2, 화:3, 수:4, 목:5, 금:6, 토: 7
SELECT TO_CHAR(SYSDATE,'d')
FROM DUAL;
--28-2 월요일
SELECT TO_CHAR(SYSDATE,'day')
FROM DUAL;
--28-3 월
SELECT TO_CHAR(SYSDATE,'dy')
FROM DUAL;
--29 자신의 생일의 요일 출력
SELECT TO_CHAR(TO_DATE('20250406','YYYYMMDD'),'day')
FROM DUAL;
--30 주문테이블에서 년과 월만 출력
SELECT TO_CHAR(ORDERDATE,'YYYY"년" MM"월"')||' 00일' 주문일
FROM ORDERS;
--31 주문테이블의 스키마
DESC ORDERS;
--32 고객명을 김o아 형식으로 출력
SELECT CONCAT(CONCAT(SUBSTR(NAME,1,1),'O'), SUBSTR(NAME, -1))
FROM CUSTOMER;
--33 현재시간의 몇시 몇분을 출력
SELECT TO_CHAR(SYSDATE,'HH"시" MI"분"')
FROM DUAL;
--34 주문번호, 주문일, 주문일로부터 10일 지난 날짜를 확정일로 출력
SELECT ORDERID, ORDERDATE, ORDERDATE +10 AS 확정일
FROM ORDERS;
--35 주문번호, 주문일을 YYYY-MM-DD형식으로 출력하고 고객번호, 도서번호 출력 단, 주문일이 2014년 7월1일~ 4일 사이 주문건에 대해
-- 주문일순으로
SELECT ORDERID 주문번호, TO_CHAR(ORDERDATE, 'YYYY-MM-DD') 주문일, CUSTID 고객번호, BOOKID 도서번호
FROM  ORDERS
WHERE ORDERDATE BETWEEN '2014-07-01' AND '2014-07-04'
ORDER BY ORDERDATE; 
--36 도서명, 가격, 가격에 10%인상된 금액
SELECT BOOKNAME, PRICE, PRICE*1.1
FROM BOOK;
--37 BOOK2 <- CREATE TABLE BOOK2 AS SELECT * FROM BOOK;
SELECT *
FROM BOOK2;
--38 BOOK2테이블의 가격을 10% 인상하시오.
UPDATE BOOK2
SET PRICE = PRICE * 1.1;

SELECT *
FROM BOOK2;
--39 실행취소
ROLLBACK;

--1 절대치: 15
SELECT ABS(-15)
FROM DUAL;
--2 CEIL: 올림  ->16
SELECT CEIL(15.7)
FROM DUAL;
--3 코사인 함수값
SELECT COS(3.14159)
FROM DUAL;
--4 FLOOR() 내림
SELECT FLOOR(15.7)
FROM DUAL;
--5 로그 10을 밑으로한 200의 로그값 : 2.3010
SELECT LOG(10,200)
FROM DUAL;
--6 11을 4로 나눈 나머지: 3
SELECT MOD(11,4)
FROM DUAL;
--7 제곱 : 3*3
SELECT POWER(3,2)
FROM DUAL;
--8 ROUND() : 반올림 16
SELECT ROUND(15.7)
FROM DUAL;
--9 SIGN() : 부호: 음수: -1, 0: 0, 양수: 1
SELECT  SIGN(-15)
FROM DUAL;
--10 절삭: 소수이하 버림 
SELECT TRUNC(15.7)
FROM DUAL;
SELECT FLOOR(15.7)
FROM DUAL;
--11 아스키코드값에 해당되는 문자 67-> C
SELECT CHR(67)
FROM DUAL;
--12 결합 HAPPY Birthday
SELECT CONCAT('HAPPY ','Birthday') 
FROM DUAL;
--13 lower(): 소문자로 변환
SELECT LOWER('Birthday')
FROM DUAL;
--14 전체칸에 맞게 왼쪽을 *로 채우기 
SELECT  LPAD('Page 1',15,'*')
FROM DUAL;
--15 LTRIM: 왼쪽에 해당문자를 자름
SELECT LTRIM('Page 1', 'aP')
FROM DUAL;
--16 REPLACE(): 다른 문자열로 대체
SELECT REPLACE('JACK','J','BL')
FROM DUAL;
--17 RPAD(): 오른쪽에 해당문자로 채우기
SELECT RPAD('Page 1', 15,'*')
FROM DUAL;
--18 RTRIM(): 오른쪽
SELECT RTRIM('Page 111111', '1')
FROM DUAL;
--19 SUBSTR(문자열, 시작위치, 개수)=>CDEF
SELECT SUBSTR('ABCDEFG',3,4)
FROM DUAL;
--20 AA00
SELECT TRIM(LEADING 0 FROM '00AA00')
FROM DUAL;
--21  AA00
SELECT LTRIM('00AA00', '0')
FROM DUAL;
--22  AA
SELECT TRIM(0 FROM '00AA00')
FROM DUAL;
--23 문자열 중 세번째 글자 이후에 나오는 두번째 OR의 위치: 14
SELECT INSTR('CORPORATE FLOOR','OR',3,2)
FROM DUAL;
--24 LENGTH(): 글자수
SELECT LENGTH('Birthday')
FROM DUAL;
--25 해당날짜의 몇개월 뒤 날짜 구하기 => 2014/06/21
SELECT ADD_MONTHS('2014/05/21',1)
FROM DUAL;
--26 LAST_DAY(SYSDATE) :오늘이 속한 달의 마지막날
SELECT  LAST_DAY(SYSDATE)
FROM DUAL;
--27 해당 일이 지난 첫번째 요일에 해당 날짜 2025/04/15
SELECT NEXT_DAY(SYSDATE,'화')
FROM DUAL;
--28 날의 반올림은 12시간을 넘으면 다음날로, 안넘으면 해당일
SELECT ROUND(SYSDATE)
FROM DUAL;
--29 오늘의 날짜
SELECT SYSDATE
FROM DUAL;
--30 날짜를 원하는 형식으로 출력 년월일 시분초 오전 요일 
SELECT TO_CHAR(SYSDATE, 'YYYY"년"MM"월"DD"일" HH24:MI:SS PM DY') 
FROM DUAL;
--31
SELECT TO_CHAR(123)||'등' 
FROM DUAL;

SELECT 1.23||'등' 
FROM DUAL;
--32
SELECT TO_DATE('12 05 2014', 'DD MM YYYY')
FROM DUAL;
--33 문자열을 숫자로 변환
SELECT TO_NUMBER('12.3')
FROM DUAL;
--34 DECODE(값1, 값2, 값3, 값4) : 값1과 값2가 같으면 값3, 아니면 값4를 출력
--앞 두개 값이 같으면 세번째 값 출력
SELECT DECODE(1,1,'aa','bb') 
FROM DUAL;
-- 앞의 두개 값이 다르면 마지막값 출력
SELECT DECODE(1,2,'aa','bb') 
FROM DUAL;
--35 NULLIF(값1, 값2) 값1과 값2가 같으면 NULL, 다르면 값1
-- 두개가 다르므로 값1 출력
SELECT  NULLIF(123,345)
FROM DUAL;
-- 두개가 같으므로  NULL 출력
SELECT  NULLIF(123,123)
FROM DUAL;
--36 NVL(값1, 값2) : 값1이 NULL이면 값2 출력
SELECT NVL(NULL, 123)
FROM DUAL;
--값1이 NULL이 아니므로 값1 출력
SELECT NVL(123, 1000)
FROM DUAL;
--36 PHONE 이 NULL인 경우 0
SELECT NVL(PHONE, 0)
FROM CUSTOMER;
--PHONE이 NULL인 경우 NULL그대로 출력 
SELECT NVL(PHONE, NULL)
FROM CUSTOMER;
--37 PHONE이 NULL인 경우 없음 출력
SELECT NVL(PHONE, '없음') 
FROM CUSTOMER;
--38 
CREATE TABLE MYBOOK(
BOOKID NUMBER,
PRICE NUMBER);

INSERT INTO MYBOOK VALUES(1,10000);
INSERT INTO MYBOOK VALUES(2,20000);
INSERT INTO MYBOOK(BOOKID) VALUES(3);
INSERT INTO MYBOOK VALUES(4, NULL);

SELECT * FROM MYBOOK;
DELETE FROM MYBOOK WHERE BOOKID=4;
--39 MYBOOK테이블에서 가격 합계, 평균, 행 개수, 가격개수
SELECT SUM(PRICE), AVG(PRICE), COUNT(*), COUNT(PRICE)
FROM MYBOOK;
--''를 삽입하면 결과적으로 NULL이 입력됨.
INSERT INTO MYBOOK VALUES(5, '');
--40
SELECT PRICE
FROM MYBOOK
WHERE PRICE = '';
--41 
SELECT PRICE
FROM MYBOOK
WHERE PRICE = '';

SELECT *
FROM MYBOOK
WHERE PRICE IS NULL;
--42 행번호와 고객번호, 고객명, 연락처 제일 위 2개 대상
SELECT ROWNUM "순번" , CUSTID, NAME, PHONE
FROM CUSTOMER
WHERE ROWNUM <= 2;
--오류 발생
SELECT ROWNUM "순번" , *
FROM CUSTOMER;
--43
SELECT * FROM MYBOOK;
--44
DELETE FROM MYBOOK 
WHERE BOOKID=5;

DELETE FROM MYBOOK 
WHERE BOOKID=5;

--45 --2
SELECT BOOKID, NVL(PRICE,0) FROM MYBOOK;
--46 --3 가격이 정해지지 않은 행 검색
SELECT *
FROM MYBOOK
WHERE PRICE IS NULL;
--47 --4  NULL과  ''은 다르다.
SELECT *
FROM MYBOOK
WHERE PRICE =''; 
--48  --5
SELECT BOOKID, PRICE+100
FROM MYBOOK;
--49 --6 해당되는 것이 없을 경우 SUM(), AVG() 는 NULL
--COUNT()는 0이 됨.
SELECT SUM(PRICE), AVG(PRICE), COUNT(*)
FROM MYBOOK
WHERE BOOKID>=4;
--50  --7 PRICE가 NULL인 것 제외
SELECT COUNT(*), COUNT(PRICE)
FROM MYBOOK;
--51 --8
SELECT SUM(PRICE), AVG(PRICE)
FROM MYBOOK;
--52 -1 BOOK테이블 내용
SELECT * FROM BOOK;
--53 -2 BOOK테이블 내용 중 상위 5개 
SELECT * FROM BOOK
WHERE ROWNUM <=5;
--54 --3  위치상 상위 5개 뽑아 그것을 가격순으로 정렬
--FROM, WHERE, SELECT, ORDER BY : 위치상 상위 5개 뽑고 정렬
SELECT * 
FROM BOOK
WHERE ROWNUM <=5
ORDER BY PRICE;
--55 -4  FROM 절에 SUB QUERY -> IN-LINE VIEW
SELECT * 
FROM (SELECT * 
     FROM BOOK 
     ORDER BY PRICE) B
WHERE ROWNUM <=5;
--56
SELECT *
FROM (SELECT * 
      FROM BOOK 
      ORDER BY PRICE DESC) B
WHERE ROWNUM <=5
ORDER BY PRICE DESC;
--위치상 상위 5개를 정렬
SELECT * 
FROM BOOK 
WHERE ROWNUM <=5
ORDER BY PRICE DESC;
--56 -5 위치상 위의  5개를 정렬
SELECT *
FROM (SELECT * FROM BOOK WHERE ROWNUM<=5) B
ORDER BY PRICE;

--57 -6 위치상 상위 5개를 정렬
SELECT *
FROM (SELECT * FROM BOOK WHERE ROWNUM <=5 ORDER BY PRICE);

--58 NVL2(값1, 값2, 값3) : 값1이 값이 있으면 값2, NULL이면 값3
SELECT NAME, NVL2(PHONE,'있음','없음' )
FROM CUSTOMER;
--59 주문테이블에서 평균 판매가 이하인 주문번호와 판매가
SELECT ORDERID, SALEPRICE
FROM ORDERS
WHERE SALEPRICE<=(SELECT AVG(SALEPRICE)
                  FROM ORDERS);
--60 평균 도서가격보다 비싼 도서번호, 도서명, 정가
SELECT BOOKID, BOOKNAME, PRICE
FROM BOOK
WHERE PRICE > (SELECT AVG(PRICE)
               FROM BOOK);
--61 각 고객번호의 평균 주문금액
--TRUNC(): 자름   -5.7 => -5
SELECT CUSTID,TRUNC(AVG(SALEPRICE))
FROM ORDERS
GROUP BY CUSTID;
--FLOOR() :내림   FLOOR(-5.7)=> -6
SELECT CUSTID,FLOOR(AVG(SALEPRICE))
FROM ORDERS
GROUP BY CUSTID;
--ROUND(): 반올림
SELECT CUSTID,ROUND(AVG(SALEPRICE))
FROM ORDERS
GROUP BY CUSTID;

--62 각 고객번호의 평균 주문금액보다 큰 금액의 주문번호, 고객번호, 판매가
SELECT ORDERID, CUSTID, SALEPRICE
FROM ORDERS O1
WHERE SALEPRICE  > ( SELECT AVG(SALEPRICE)
                   FROM ORDERS O2
                   WHERE O1.CUSTID = O2.CUSTID);
--63 각 도서의 평균 주문금액보다 크거나 같은 금액의 주문번호, 도서번호, 도서명, 판매가                   
SELECT O.ORDERID, O.BOOKID, B.BOOKNAME, O.SALEPRICE
FROM ORDERS O JOIN BOOK B ON(B.BOOKID=O.BOOKID)
WHERE SALEPRICE >= (SELECT AVG(SALEPRICE)
                       FROM ORDERS O2
                       WHERE  O.BOOKID=O2.BOOKID);
SELECT BOOKID, AVG(SALEPRICE)
FROM ORDERS
GROUP BY BOOKID;
--64 대한민국에 거주하는 고객이 주문한 도서의 총 판매액  -JOIN, SUB QUERY
SELECT SUM(SALEPRICE)
FROM ORDERS O JOIN CUSTOMER C ON(O.CUSTID=C.CUSTID)
WHERE ADDRESS LIKE '대한민국%';


SELECT SUM(SALEPRICE)
FROM ORDERS
WHERE CUSTID IN (SELECT CUSTID
                 FROM CUSTOMER
                 WHERE ADDRESS LIKE '대한민국%');
--65 DDL, DML, DCL
SELECT
FROM 
WHERE
GROUP BY
HAVING
ORDER BY;
--66
INSERT INTO MYBOOK VALUES(6,10000);
SELECT * FROM MYBOOK;
--67 MYBOOK 테이블에 AUTHOR 가변형 문자 20자로 속성 추가
ALTER TABLE MYBOOK ADD AUTHOR VARCHAR2(20); 
DESC MYBOOK;
--68 MYBOOK에 BOOKID를 기본키로 지정
ALTER TABLE MYBOOK ADD CONSTRAINT PK_MYBOOK_BOOKID PRIMARY KEY(BOOKID);

DESC MYBOOK;
SELECT * FROM USER_CONSTRAINTS;
--69 MYBOOK에 BOOKID를 기본키 제거
ALTER TABLE MYBOOK DROP CONSTRAINT PK_MYBOOK_BOOKID;
DESC MYBOOK;
--70 MYBOOK테이블에 ISBN으로 고정형 13자 문자형 추가
ALTER TABLE MYBOOK ADD ISBN CHAR(13);
DESC MYBOOK;
--71 MYBOOK테이블에 4번15000, 'ABC', '1234-5678-900' 삽입
SELECT * FROM MYBOOK;
INSERT INTO MYBOOK VALUES(4, 15000, 'ABC', '1234-5678-900');
SELECT * FROM MYBOOK;
--72 4번의 저자를 AAA로 수정
UPDATE MYBOOK SET AUTHOR = 'AAA' WHERE BOOKID=4;
SELECT * FROM MYBOOK;
--73 ISBN을 가변형 15자로 수정
ALTER TABLE MYBOOK MODIFY ISBN VARCHAR2(15);
--74 ISBN 속성 삭제
ALTER TABLE MYBOOK DROP COLUMN ISBN;
DESC MYBOOK;
--75 PUBLISHER테이블 생성
--PID:출판사번호 :NUMBER(3), 출판사명: PUB: VHARCHAR2(20), 주소:ADDR: VARCHAR2(20);
CREATE TABLE PUBLISHER(
PID NUMBER(3),
PUB VARCHAR2(20),
ADDR VARCHAR2(20));
--76 PID를 기본키로 지정
ALTER TABLE PUBLISHER ADD CONSTRAINT PK_PUBLISHER_PID PRIMARY KEY(PID);

-77 MYBOOK 테이블에 PID 숫자형3자 추가하는데 PUBLISHER테이블의 PID를 참조하도록 하고 PID속성 추가
ALTER TABLE MYBOOK ADD PID NUMBER(3);
ALTER TABLE MYBOOK ADD CONSTRAINT FK_MYBOOK_PID FOREIGN KEY(PID) REFERENCES PUBLISHER(PID);

--78 MYBOOK테이블의 PID삭제
ALTER TABLE MYBOOK DROP CONSTRAINT FK_MYBOOK_PID;
ALTER TABLE MYBOOK DROP COLUMN PID;
ALTER TABLE MYBOOK ADD PID NUMBER(3) REFERENCES PUBLISHER(PID);
SELECT * FROM USER_CONSTRAINTS;



--





































